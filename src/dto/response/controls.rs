use crate::dto::PaginatedResponse;
use crate::entity::controls::Model as ControlModel;
use crate::entity::sea_orm_active_enums::MonitorType;
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

#[derive(Debug, Clone, Deserialize, Serialize, ToSchema)]
pub struct ControlResponse {
    pub id: u32,
    pub name: String,
    #[serde(rename = "type")]
    pub r#type: MonitorType,
    pub protocol: Option<String>,
    pub can_wake: u8,
    pub can_sleep: u8,
    pub can_reset: u8,
    pub can_reboot: u8,
    pub can_zoom: u8,
    pub can_auto_zoom: u8,
    pub can_zoom_abs: u8,
    pub can_zoom_rel: u8,
    pub can_zoom_con: u8,
    pub min_zoom_range: Option<u32>,
    pub max_zoom_range: Option<u32>,
    pub min_zoom_step: Option<u32>,
    pub max_zoom_step: Option<u32>,
    pub has_zoom_speed: u8,
    pub min_zoom_speed: Option<u32>,
    pub max_zoom_speed: Option<u32>,
    pub can_focus: u8,
    pub can_auto_focus: u8,
    pub can_focus_abs: u8,
    pub can_focus_rel: u8,
    pub can_focus_con: u8,
    pub min_focus_range: Option<u32>,
    pub max_focus_range: Option<u32>,
    pub min_focus_step: Option<u32>,
    pub max_focus_step: Option<u32>,
    pub has_focus_speed: u8,
    pub min_focus_speed: Option<u32>,
    pub max_focus_speed: Option<u32>,
    pub can_iris: u8,
    pub can_auto_iris: u8,
    pub can_iris_abs: u8,
    pub can_iris_rel: u8,
    pub can_iris_con: u8,
    pub min_iris_range: Option<u32>,
    pub max_iris_range: Option<u32>,
    pub min_iris_step: Option<u32>,
    pub max_iris_step: Option<u32>,
    pub has_iris_speed: u8,
    pub min_iris_speed: Option<u32>,
    pub max_iris_speed: Option<u32>,
    pub can_gain: u8,
    pub can_auto_gain: u8,
    pub can_gain_abs: u8,
    pub can_gain_rel: u8,
    pub can_gain_con: u8,
    pub min_gain_range: Option<u32>,
    pub max_gain_range: Option<u32>,
    pub min_gain_step: Option<u32>,
    pub max_gain_step: Option<u32>,
    pub has_gain_speed: u8,
    pub min_gain_speed: Option<u32>,
    pub max_gain_speed: Option<u32>,
    pub can_white: u8,
    pub can_auto_white: u8,
    pub can_white_abs: u8,
    pub can_white_rel: u8,
    pub can_white_con: u8,
    pub min_white_range: Option<u32>,
    pub max_white_range: Option<u32>,
    pub min_white_step: Option<u32>,
    pub max_white_step: Option<u32>,
    pub has_white_speed: u8,
    pub min_white_speed: Option<u32>,
    pub max_white_speed: Option<u32>,
    pub has_presets: u8,
    pub num_presets: u8,
    pub has_home_preset: u8,
    pub can_set_presets: u8,
    pub can_move: u8,
    pub can_move_diag: u8,
    pub can_move_map: u8,
    pub can_move_abs: u8,
    pub can_move_rel: u8,
    pub can_move_con: u8,
    pub can_pan: u8,
    pub min_pan_range: Option<i32>,
    pub max_pan_range: Option<i32>,
    pub min_pan_step: Option<i32>,
    pub max_pan_step: Option<i32>,
    pub has_pan_speed: u8,
    pub min_pan_speed: Option<i32>,
    pub max_pan_speed: Option<i32>,
    pub has_turbo_pan: u8,
    pub turbo_pan_speed: Option<i32>,
    pub can_tilt: u8,
    pub min_tilt_range: Option<i32>,
    pub max_tilt_range: Option<i32>,
    pub min_tilt_step: Option<i32>,
    pub max_tilt_step: Option<i32>,
    pub has_tilt_speed: u8,
    pub min_tilt_speed: Option<i32>,
    pub max_tilt_speed: Option<i32>,
    pub has_turbo_tilt: u8,
    pub turbo_tilt_speed: Option<i32>,
    pub can_auto_scan: u8,
    pub num_scan_paths: u8,
}

impl From<&ControlModel> for ControlResponse {
    fn from(model: &ControlModel) -> Self {
        Self {
            id: model.id,
            name: model.name.clone(),
            r#type: model.r#type.clone(),
            protocol: model.protocol.clone(),
            can_wake: model.can_wake,
            can_sleep: model.can_sleep,
            can_reset: model.can_reset,
            can_reboot: model.can_reboot,
            can_zoom: model.can_zoom,
            can_auto_zoom: model.can_auto_zoom,
            can_zoom_abs: model.can_zoom_abs,
            can_zoom_rel: model.can_zoom_rel,
            can_zoom_con: model.can_zoom_con,
            min_zoom_range: model.min_zoom_range,
            max_zoom_range: model.max_zoom_range,
            min_zoom_step: model.min_zoom_step,
            max_zoom_step: model.max_zoom_step,
            has_zoom_speed: model.has_zoom_speed,
            min_zoom_speed: model.min_zoom_speed,
            max_zoom_speed: model.max_zoom_speed,
            can_focus: model.can_focus,
            can_auto_focus: model.can_auto_focus,
            can_focus_abs: model.can_focus_abs,
            can_focus_rel: model.can_focus_rel,
            can_focus_con: model.can_focus_con,
            min_focus_range: model.min_focus_range,
            max_focus_range: model.max_focus_range,
            min_focus_step: model.min_focus_step,
            max_focus_step: model.max_focus_step,
            has_focus_speed: model.has_focus_speed,
            min_focus_speed: model.min_focus_speed,
            max_focus_speed: model.max_focus_speed,
            can_iris: model.can_iris,
            can_auto_iris: model.can_auto_iris,
            can_iris_abs: model.can_iris_abs,
            can_iris_rel: model.can_iris_rel,
            can_iris_con: model.can_iris_con,
            min_iris_range: model.min_iris_range,
            max_iris_range: model.max_iris_range,
            min_iris_step: model.min_iris_step,
            max_iris_step: model.max_iris_step,
            has_iris_speed: model.has_iris_speed,
            min_iris_speed: model.min_iris_speed,
            max_iris_speed: model.max_iris_speed,
            can_gain: model.can_gain,
            can_auto_gain: model.can_auto_gain,
            can_gain_abs: model.can_gain_abs,
            can_gain_rel: model.can_gain_rel,
            can_gain_con: model.can_gain_con,
            min_gain_range: model.min_gain_range,
            max_gain_range: model.max_gain_range,
            min_gain_step: model.min_gain_step,
            max_gain_step: model.max_gain_step,
            has_gain_speed: model.has_gain_speed,
            min_gain_speed: model.min_gain_speed,
            max_gain_speed: model.max_gain_speed,
            can_white: model.can_white,
            can_auto_white: model.can_auto_white,
            can_white_abs: model.can_white_abs,
            can_white_rel: model.can_white_rel,
            can_white_con: model.can_white_con,
            min_white_range: model.min_white_range,
            max_white_range: model.max_white_range,
            min_white_step: model.min_white_step,
            max_white_step: model.max_white_step,
            has_white_speed: model.has_white_speed,
            min_white_speed: model.min_white_speed,
            max_white_speed: model.max_white_speed,
            has_presets: model.has_presets,
            num_presets: model.num_presets,
            has_home_preset: model.has_home_preset,
            can_set_presets: model.can_set_presets,
            can_move: model.can_move,
            can_move_diag: model.can_move_diag,
            can_move_map: model.can_move_map,
            can_move_abs: model.can_move_abs,
            can_move_rel: model.can_move_rel,
            can_move_con: model.can_move_con,
            can_pan: model.can_pan,
            min_pan_range: model.min_pan_range,
            max_pan_range: model.max_pan_range,
            min_pan_step: model.min_pan_step,
            max_pan_step: model.max_pan_step,
            has_pan_speed: model.has_pan_speed,
            min_pan_speed: model.min_pan_speed,
            max_pan_speed: model.max_pan_speed,
            has_turbo_pan: model.has_turbo_pan,
            turbo_pan_speed: model.turbo_pan_speed,
            can_tilt: model.can_tilt,
            min_tilt_range: model.min_tilt_range,
            max_tilt_range: model.max_tilt_range,
            min_tilt_step: model.min_tilt_step,
            max_tilt_step: model.max_tilt_step,
            has_tilt_speed: model.has_tilt_speed,
            min_tilt_speed: model.min_tilt_speed,
            max_tilt_speed: model.max_tilt_speed,
            has_turbo_tilt: model.has_turbo_tilt,
            turbo_tilt_speed: model.turbo_tilt_speed,
            can_auto_scan: model.can_auto_scan,
            num_scan_paths: model.num_scan_paths,
        }
    }
}

/// Paginated response for controls
#[derive(Debug, Clone, Deserialize, Serialize, ToSchema)]
pub struct PaginatedControlsResponse {
    pub items: Vec<ControlResponse>,
    pub total: u64,
    pub per_page: u64,
    pub current_page: u64,
    pub last_page: u64,
}

impl From<PaginatedResponse<ControlResponse>> for PaginatedControlsResponse {
    fn from(r: PaginatedResponse<ControlResponse>) -> Self {
        Self {
            items: r.items,
            total: r.total,
            per_page: r.per_page,
            current_page: r.current_page,
            last_page: r.last_page,
        }
    }
}
